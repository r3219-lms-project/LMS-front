<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.local">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.local" />
              <option name="originalContent" value="NEXT_PUBLIC_COURSES_API=http://localhost:8081&#10;NEXT_PUBLIC_AUTH_API=http://localhost:8084/api/v1/auth&#10;NEXT_PUBLIC_USER_API=http://localhost:8082/api/v1/users&#10;" />
              <option name="updatedContent" value="NEXT_PUBLIC_COURSES_API=http://localhost:8081&#10;NEXT_PUBLIC_AUTH_API=http://localhost:8084/api/v1/auth&#10;NEXT_PUBLIC_USER_API=http://localhost:8082/api/v1/users&#10;NEXT_PUBLIC_PROGRESS_API=http://localhost:8088&#10;NEXT_PUBLIC_API_GATEWAY_URL=http://localhost:8080&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/api/groupApi.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/api/groupApi.ts" />
              <option name="originalContent" value="import type {&#10;    Group,&#10;    CreateGroupRequest,&#10;    CreateGroupResponse,&#10;    UpdateGroupRequest,&#10;    ChangeGroupStatusRequest,&#10;} from '@/types/group';&#10;&#10;const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';&#10;&#10;async function fetchWithErrorHandling(url: string, options?: RequestInit) {&#10;    try {&#10;        const response = await fetch(url, {&#10;            ...options,&#10;            mode: 'cors',&#10;            credentials: 'omit',&#10;        });&#10;&#10;        if (!response.ok) {&#10;            const errorText = await response.text();&#10;            throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);&#10;        }&#10;&#10;        return response;&#10;    } catch (error) {&#10;        if (error instanceof TypeError &amp;&amp; error.message.includes('fetch')) {&#10;            throw new Error('Не удалось подключиться к серверу. Проверьте, что сервер запущен на ' + API_BASE_URL);&#10;        }&#10;        throw error;&#10;    }&#10;}&#10;&#10;export const groupApi = {&#10;    async getAllGroups(): Promise&lt;Group[]&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/groups`);&#10;        return response.json();&#10;    },&#10;&#10;    async getGroupById(id: string): Promise&lt;Group&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/groups/${id}`);&#10;        return response.json();&#10;    },&#10;&#10;    async createGroup(data: CreateGroupRequest): Promise&lt;CreateGroupResponse&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/groups`, {&#10;            method: 'POST',&#10;            headers: {&#10;                'Content-Type': 'application/json',&#10;            },&#10;            body: JSON.stringify(data),&#10;        });&#10;        return response.json();&#10;    },&#10;&#10;    async updateGroup(id: string, data: UpdateGroupRequest): Promise&lt;Group&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/groups/${id}`, {&#10;            method: 'PUT',&#10;            headers: {&#10;                'Content-Type': 'application/json',&#10;            },&#10;            body: JSON.stringify(data),&#10;        });&#10;        return response.json();&#10;    },&#10;&#10;    async deleteGroup(id: string): Promise&lt;void&gt; {&#10;        await fetchWithErrorHandling(`${API_BASE_URL}/api/groups/${id}`, {&#10;            method: 'DELETE',&#10;        });&#10;    },&#10;&#10;    async changeStatus(id: string, data: ChangeGroupStatusRequest): Promise&lt;Group&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/groups/${id}/status`, {&#10;            method: 'PATCH',&#10;            headers: {&#10;                'Content-Type': 'application/json',&#10;            },&#10;            body: JSON.stringify(data),&#10;        });&#10;        return response.json();&#10;    },&#10;};&#10;" />
              <option name="updatedContent" value="import type {&#10;    Group,&#10;    CreateGroupRequest,&#10;    UpdateGroupRequest,&#10;    ChangeGroupStatusRequest,&#10;} from '@/types/group';&#10;&#10;const API_BASE_URL = process.env.NEXT_PUBLIC_API_GATEWAY_URL || 'http://localhost:8080';&#10;&#10;async function fetchWithErrorHandling(url: string, options?: RequestInit) {&#10;    try {&#10;        const response = await fetch(url, {&#10;            ...options,&#10;            mode: 'cors',&#10;            credentials: 'omit',&#10;        });&#10;&#10;        if (!response.ok) {&#10;            const errorText = await response.text();&#10;            throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);&#10;        }&#10;&#10;        return response;&#10;    } catch (error) {&#10;        if (error instanceof TypeError &amp;&amp; error.message.includes('fetch')) {&#10;            throw new Error('Не удалось подключиться к серверу. Проверьте, что сервер запущен на ' + API_BASE_URL);&#10;        }&#10;        throw error;&#10;    }&#10;}&#10;&#10;export const groupApi = {&#10;    async getAllGroups(): Promise&lt;Group[]&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/v1/groups`);&#10;        return response.json();&#10;    },&#10;&#10;    async getGroupById(id: string): Promise&lt;Group&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/v1/groups/${id}`);&#10;        return response.json();&#10;    },&#10;&#10;    async createGroup(data: CreateGroupRequest): Promise&lt;Group&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/v1/groups`, {&#10;            method: 'POST',&#10;            headers: {&#10;                'Content-Type': 'application/json',&#10;            },&#10;            body: JSON.stringify(data),&#10;        });&#10;        return response.json();&#10;    },&#10;&#10;    async updateGroup(id: string, data: UpdateGroupRequest): Promise&lt;Group&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/v1/groups/${id}`, {&#10;            method: 'PUT',&#10;            headers: {&#10;                'Content-Type': 'application/json',&#10;            },&#10;            body: JSON.stringify(data),&#10;        });&#10;        return response.json();&#10;    },&#10;&#10;    async deleteGroup(id: string): Promise&lt;void&gt; {&#10;        await fetchWithErrorHandling(`${API_BASE_URL}/api/v1/groups/${id}`, {&#10;            method: 'DELETE',&#10;        });&#10;    },&#10;&#10;    async changeStatus(id: string, data: ChangeGroupStatusRequest): Promise&lt;Group&gt; {&#10;        const response = await fetchWithErrorHandling(`${API_BASE_URL}/api/v1/groups/${id}/status`, {&#10;            method: 'PATCH',&#10;            headers: {&#10;                'Content-Type': 'application/json',&#10;            },&#10;            body: JSON.stringify(data),&#10;        });&#10;        return response.json();&#10;    },&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/api/progressApi.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/api/progressApi.ts" />
              <option name="originalContent" value="import type {&#10;    LessonProgress,&#10;    CourseProgress,&#10;    UserProgress,&#10;    CourseProgressStats,&#10;} from '@/types/progress';&#10;&#10;const API_BASE_URL = process.env.NEXT_PUBLIC_PROGRESS_API || 'http://localhost:8088';&#10;const JSON_HEADERS = { 'Content-Type': 'application/json' };&#10;&#10;async function safeFetch(url: string, options?: RequestInit): Promise&lt;Response&gt; {&#10;    try {&#10;        const res = await fetch(url, options);&#10;        if (!res.ok) {&#10;            throw new Error(`API ${res.status} ${res.statusText}`);&#10;        }&#10;        return res;&#10;    } catch (error) {&#10;        // Преобразуем сетевые ошибки в обычные Error, чтобы они перехватывались try-catch&#10;        if (error instanceof TypeError) {&#10;            throw new Error('Network error');&#10;        }&#10;        throw error;&#10;    }&#10;}&#10;&#10;/** POST /progress/lessons/{lessonId}/complete */&#10;export async function completeLesson(lessonId: string): Promise&lt;LessonProgress&gt; {&#10;    const res = await safeFetch(`${API_BASE_URL}/progress/lessons/${lessonId}/complete`, {&#10;        method: 'POST',&#10;        headers: JSON_HEADERS,&#10;        credentials: 'include',&#10;        cache: 'no-store',&#10;    });&#10;    return res.json();&#10;}&#10;&#10;/** GET /progress/courses/{courseId} */&#10;export async function getCourseProgress(courseId: string): Promise&lt;CourseProgress&gt; {&#10;    const res = await safeFetch(`${API_BASE_URL}/progress/courses/${courseId}`, {&#10;        credentials: 'include',&#10;        cache: 'no-store',&#10;    });&#10;    return res.json();&#10;}&#10;&#10;/** GET /progress/users/me */&#10;export async function getUserProgress(): Promise&lt;UserProgress&gt; {&#10;    const res = await safeFetch(`${API_BASE_URL}/progress/users/me`, {&#10;        credentials: 'include',&#10;        cache: 'no-store',&#10;    });&#10;    return res.json();&#10;}&#10;&#10;/** GET /progress/courses/{courseId}/stats */&#10;export async function getCourseProgressStats(courseId: string): Promise&lt;CourseProgressStats&gt; {&#10;    const res = await safeFetch(`${API_BASE_URL}/progress/courses/${courseId}/stats`, {&#10;        credentials: 'include',&#10;        cache: 'no-store',&#10;    });&#10;    return res.json();&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import type {&#10;    LessonProgress,&#10;    CourseProgress,&#10;    UserProgress,&#10;    CourseProgressStats,&#10;} from '@/types/progress';&#10;&#10;const API_BASE_URL = process.env.NEXT_PUBLIC_PROGRESS_API!;&#10;const JSON_HEADERS = { 'Content-Type': 'application/json' };&#10;&#10;async function safeFetch(url: string, options?: RequestInit): Promise&lt;Response&gt; {&#10;    try {&#10;        const res = await fetch(url, options);&#10;        if (!res.ok) {&#10;            throw new Error(`API ${res.status} ${res.statusText}`);&#10;        }&#10;        return res;&#10;    } catch (error) {&#10;        // Преобразуем сетевые ошибки в обычные Error, чтобы они перехватывались try-catch&#10;        if (error instanceof TypeError) {&#10;            throw new Error('Network error');&#10;        }&#10;        throw error;&#10;    }&#10;}&#10;&#10;/** POST /api/v1/progress/lessons/{lessonId}/complete */&#10;export async function completeLesson(lessonId: string): Promise&lt;LessonProgress&gt; {&#10;    const res = await safeFetch(`${API_BASE_URL}/api/v1/progress/lessons/${lessonId}/complete`, {&#10;        method: 'POST',&#10;        headers: JSON_HEADERS,&#10;        credentials: 'include',&#10;        cache: 'no-store',&#10;    });&#10;    return res.json();&#10;}&#10;&#10;/** GET /api/v1/progress/courses/{courseId} */&#10;export async function getCourseProgress(courseId: string): Promise&lt;CourseProgress&gt; {&#10;    const res = await safeFetch(`${API_BASE_URL}/api/v1/progress/courses/${courseId}`, {&#10;        credentials: 'include',&#10;        cache: 'no-store',&#10;    });&#10;    return res.json();&#10;}&#10;&#10;/** GET /api/v1/progress/users/me */&#10;export async function getUserProgress(): Promise&lt;UserProgress&gt; {&#10;    const res = await safeFetch(`${API_BASE_URL}/api/v1/progress/users/me`, {&#10;        credentials: 'include',&#10;        cache: 'no-store',&#10;    });&#10;    return res.json();&#10;}&#10;&#10;/** GET /api/v1/progress/courses/{courseId}/stats */&#10;export async function getCourseProgressStats(courseId: string): Promise&lt;CourseProgressStats&gt; {&#10;    const res = await safeFetch(`${API_BASE_URL}/api/v1/progress/courses/${courseId}/stats`, {&#10;        credentials: 'include',&#10;        cache: 'no-store',&#10;    });&#10;    return res.json();&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>